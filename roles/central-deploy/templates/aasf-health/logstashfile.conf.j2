input {
    file {
        path => "/tmp/logs/ms.log"
        type => "log"
        start_position => "beginning"
    }
}

filter {
    grok {
        match => { "message" => "\[%{GREEDYDATA:data}\]\[%{NUMBER:epochtime}\]\[%{GREEDYDATA:throwable}\]\[%{JAVACLASS:logclass}\]\[%{LOGLEVEL:eventloglevel}\]\[%{GREEDYDATA:runtimeinsid}\] %{TIMESTAMP_ISO8601:orgeventlogtime}" }
    }

    date {
        match => [ "orgeventlogtime", "YYYY-MM-dd'T'HH:mm:ss", "YYYY-MM-dd HH:mm:ss","HH:mm:ss MMM dd yyyy","YYYY-MM-dd HH:mm:ss,SSS","yyyy-MM-dd'T'HH:mm:ss.SSSZ","yyyy-MM-dd'T'HH:mm:ss.SSSZ+0300", "yyyy-MM-dd'T'HH:mm:ss.SSSSSS+0200", "yyyy-MM-dd'T'HH:mm:ss.SSSSSZ+0200", "YYYY-MM-dd'T'HH:mm:ssZ","YYYY-MM-dd'T'HH:mm:ss.sssZ"]
        target => "eventlogtime"
    }

    ruby {
        code => "require 'digest/md5';
        event['computed_id'] = Digest::MD5.hexdigest(event['runtimeinsid'] + event['orgeventlogtime'] + event['eventloglevel'] + event['logclass'] )"
    }
}

output {
    elasticsearch { hosts => ["{% for es_server_ip in groups['elasticsearch-servers'] %}{{es_server_ip}}:{{ hostvars[es_server_ip]['elasticsearch_server_port'] }}{% if not loop.last %},{% endif %}{% endfor %}"] document_id => "%{computed_id}"}
    stdout { codec => rubydebug }
}
